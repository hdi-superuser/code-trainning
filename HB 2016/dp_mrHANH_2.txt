Ex::To hop chap k cua n phan tu {
    backtrack(i, size) {
        if (i == n) result++;
        // ko chon phan tu i+1
        backtrack(i+1, size);
        // chon phan tu i+1
        backtrack(i+1, size+1);
    }

    f[i][size] = so tap con cua tap i phan tu co kich thuoc la size

    f[i][j] = i == 0 && j == 0 ? 1 : 0;
    for i in 0 -> N
        for size in 0 -> K
             f[i][size] = f[i-1][size-1] + f[i-1][size];
            [
             if (i+1 <= N) f[i+1][size] += f[i][size];
             if (i+1 <= N && size+1 <= M) f[i+1][size+1] += f[i][size];
    res = f[n][k];

    Note: Khac nhau giua bai toan dem va toi uu
        - Trong bai toan dem khong xuat hien tham so muc tieu.
        - O bai toan toi uu thuong co dang minimize/maximize. Con o bai toan
        dem co mot da thuc.
}

Ex::Cho n do vat co gia tri a[1], a[2], ..., a[n]. Khoi luong b[1], b[2], ..., b[n].
So luong c[1], c[2], ..., c[n]. Hoi co bao nhieu cach lay cac do vat so cho tong khoi luong
nho hon hoac bang M va khoi luong lon hon hoac bang V {
    backtrack(i, sw, sv) {
        if (i == n) result += (sw <= M && sv >= V) ? 1 : 0;
        for j in 0 -> c[i+1]
            if (sw + j*b[i+1] <= M)
                backtrack(i+1, sw + j*b[i+1], sv + j*a[i+1]);
    }

    f[i][sw][sv]
    f[i][j][k] = i == 0 && j == 0 && k == 0 ? 1 : 0;
    for i in 0 -> N
        for sw in 0 -> M
            for sv in 0 -> sum(a[k]*v[k])
                if (f[i][sw][sv] > 0)
                    for j in 0 -> c[i+1]
                        if (i+1 <= N && sw + j*b[i+1] <= M)
                            f[i+1][sw+j*b[i+1]][sv+j*a[i+1]] += f[i][sw][sv];
    res = sum(f[n][sw][sv])
            sw in 0 -> M
            sv in 0 -> sum(a[i]*c[i])
}
