Ham QHD:
       Backtrack(w, c, ,k, v) {
            w, c, k: tham so dieu kien
            v: tham so muc tieu
       }
       => DP: f[w][c][k] = v;
Cong thuc truy hoi:
       Backtrack(w, c, k, v) {
            if (abc) backtrack(w', c', k', v');
            if (xyz) backtrack(w", c", k", v");
       }
       => DP: if (abc) maximize/minimize(f[w'][c'][k'], v');
       v' tinh theo v;
Khoi tao:
       CT chinh:
            + backtrack(a, b, c, d) -> f[a][b][c] = d;
            + backtrack(e, f, g, h) -> f[e][f][g] = h;
       Cac gia tri con lai: f[c][l][g] = infinite;
Ket qua:
       backtrack(..) {
            if (..) maximize/minimize(result, v);
       }
Ex3:: Co n bai tap lap trinh. Thoi gian giai t1, t2, tn. Su dung tro giup chi mat thoi gian C
(su dung khong qua 1 lan). Chon mot so bai de lam. Hoi trong thoi gian M lam dc toi da bao nhieu bai {
    f[i][j][0] = max(
        f[i-1][j][1],
        f[i-1][j][0],
        f[i-1][j-t[i]][1] + 1,
        f[i-1][j-t[i]][0] + 1,
        f[i-1][j-c][0] + 1
    )
    f[i][j][1] = max(
        f[i-1][j][0],
        f[i-1][j-t[i]][0] + 1,
    )
    res = max(f[n][m][1], f[n][m][0]);

    f[i][st][copied] = done;
    for i in 0 -> N
        for st in 0 -> M
            maximize(f[i+1][st][copied], f[i][st][copied]);
            if (st + t[i+1] <= M)
                maximize(f[i+1][st+t[i+1]][copied], f[i][st][copied] + 1);
            if (copied == 0 && st+c <= M)
                maximize(f[i+1][st+c][1], f[i][st][copied] + 1);

    Dao chieu QHD: Doi tham so dieu kien va tham so muc tieu. Tim thoi gian toi thieu de lam dc k bai
    backtrack(i, done, copied, st) {
        if (i == n) minimize(result, st);
        backtrack(i+1, done, copied, st);
        if (done + 1 <= k) backtrack(i+1, done+1, copied, st+t[i+1]);
        if (done + 1 <= k) backtrack(i+1, done+1, 1, st+c);
    }

    dp {
        f[i][done][copied] = st;
        f[i][done][copied] = f[i-1][done][copied];
        f[i][done][0] = f[i-1][done-1][0] + t[i];
        f[i][done][1] = f[i-1][done-1][1] + c;
        res = max(f[i][k][copied]);

        f[i][done][copied] = st;
        f[0][0][0] = 0;
        f[i][done][copied] = infinite;
        for i in 0 -> N
            for done in 0 -> i   // kiem tra xem trang thai co hop le khong
                if (f[i][done][copied] < infinite) {
                    for copied in 0 -> 1
                        if (i+1 <= N) minimize(f[i+1][done][copied], f[i][done][copied]);
                        if (i+1 <= N) minimize(f[i+1][done+1][copied], f[i][done][copied] + t[i+1]);
                        if (i+1 <= N) minimize(f[i+1][done+1][copied], f[i][done][copied] + c);
                }
        res = max(done && min(f[i][done][0], f[i][done][1]) <= M);
    }
}

Ex::STMERGE - VOJ {

    backtrack(cost, numS, numT, last) {
        if (numS = m && numT = n) maximize(result, cost);
        if (numS+1 <= len(S)) backtrack(i+1, cost + (last == 0 ? 0 : C[numS+1][numT]), numS+1, numT, 0);
        if (numT+1 <= len(T)) backtrack(i+1, cost + (last == 1 ? 0 : C[numT+1][numS]), numS, numT+1, 1);
    }

    int newcost(x, y, i, j) {
        return x == y ? 0 : C[i][j];
    }

    dp: dp[numS][numT][last] = cost;
    for numS in 0 -> m
        for numT in 0 -> n
            for last in 0 -> 1
                if (f[numS][numT][last] < infinite)
                    if (numS + 1 <= m) minimize(f[numS+1][numT][0], f[numS][numT][last] + newcost(last, 0, numT, numS+1));
                    if (numT + 1 <= m) minimize(f[numS][numT+1][1], f[numS][numT][last] + newcost(last, 1, numS, numT+1));
}
